<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Yuujinchou (yuujinchou.Yuujinchou)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">yuujinchou</a> &#x00BB; Yuujinchou</nav><h1>Module <code>Yuujinchou</code></h1><p><b>Yuujinchou</b> is an OCaml package of name patterns. It was motivated by the &quot;import&quot; or &quot;include&quot; statements present in almost all programming languages. Here are a few examples:</p><pre>open import M -- Agda</pre><pre>import foo # Python</pre><p>The ability to import content from other files helps organize code. However, it also poses a new challenge: how could programmers prevent imported content from shadowing existing content? For example, if we already have a function <code>test</code> in the current scope, maybe we do not wish to import another function also named <code>test</code>. To address this, many programming languages allow programmers to selectively hide or rename part of the imported content:</p><pre>open import M renaming (a to b) public
-- renaming a to b, and then re-exporting the content</pre><pre>import foo as bar
# putting content of foo under the prefix bar</pre><p>We can view hiding and renaming as partial functions from names to names. I took this aspect seriously and designed a powerful (possibly overkilling) combinator calculus to express such partial functions---the library you are checking now. It supports renaming, scopes, sequencing, logical connectives, negation and tags with only six combinators in the language. For technical detail, see <a href="Pattern/index.html#core"><span>Core Language</span></a>.</p><nav class="toc"><ul><li><a href="#organization">Organization</a></li><li><a href="#how-to-use-it">How to Use It</a></li><li><a href="#namespace?">Namespace?</a></li><li><a href="#examples-from-other-languages">Examples from Other Languages</a><ul><li><a href="#haskell">Haskell</a></li><li><a href="#racket">Racket</a></li></ul></li><li><a href="#what-is-&quot;yuujinchou&quot;?">What is &quot;Yuujinchou&quot;?</a></li></ul></nav></header><section><header><h2 id="organization"><a href="#organization" class="anchor"></a>Organization</h2><p>The code is split into two parts:</p></header><dl><dt class="spec module" id="module-Pattern"><a href="#module-Pattern" class="anchor"></a><code><span class="keyword">module</span> <a href="Pattern/index.html">Pattern</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <a href="Pattern/index.html"><code>Pattern</code></a> module defines the patterns.</p></dd></dl><dl><dt class="spec module" id="module-Action"><a href="#module-Action" class="anchor"></a><code><span class="keyword">module</span> <a href="Action/index.html">Action</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <a href="Action/index.html"><code>Action</code></a> module implements the engine running the patterns.</p></dd></dl></section><section><header><h2 id="how-to-use-it"><a href="#how-to-use-it" class="anchor"></a>How to Use It</h2><pre><code class="ml">open Yuujinchou

type data = int

(** An environment is a mapping from paths to data. *)
type env = (Pattern.path, data) Hashtbl.t

(** [remap pattern env] uses the [pattern] to massage
    the environment [env]. *)
let remap pattern env =
  let compiled_pattern = Result.get_ok @@ Action.compile_ pattern in
  let new_env = Hashtbl.create @@ Hashtbl.length env in
  begin
    env |&gt; Hashtbl.iter @@ fun path data -&gt;
    match Action.run_ compiled_pattern path with
    | `NoMatch -&gt; ()
    | `Matched l -&gt; l |&gt; List.iter @@ fun (path, ()) -&gt;
      match Hashtbl.find_opt new_env path with
      | None -&gt; Hashtbl.replace new_env path data
      | Some data' -&gt;
        if data &lt;&gt; data' then
          failwith &quot;Inconsistent data assigned to the same path.&quot;
  end;
  new_env

(** [import env pattern imported] imports the environment
    [imported] massaged by [pattern] into [env]. *)
let import env pattern imported =
  Hashtbl.replace_seq env @@ Hashtbl.to_seq @@ remap pattern imported</code></pre></header></section><section><header><h2 id="namespace?"><a href="#namespace?" class="anchor"></a>Namespace?</h2><p>This library intends to treat a namespace as the prefix of a group of names. That is, there is no namespace <code>a</code>, but only a group of unrelated names that happen to have the prefix <code>a</code>.</p><p>Note that namespaces (name prefixes of unrelated items) are different from modules (groups of items that are bound together). This library does not provide special support for modules (yet).</p></header></section><section><header><h2 id="examples-from-other-languages"><a href="#examples-from-other-languages" class="anchor"></a>Examples from Other Languages</h2></header><section><header><h3 id="haskell"><a href="#haskell" class="anchor"></a>Haskell</h3><pre>import Mod -- x is available an both x and Mod.x</pre><pre><code class="ml">join [any; renaming_prefix [] [&quot;Mod&quot;]]</code></pre><pre>import Mod (x,y)</pre><pre><code class="ml">join [only [&quot;x&quot;]; only [&quot;y&quot;]]</code></pre><pre>import qualified Mod</pre><pre><code class="ml">join [renaming_prefix [] [&quot;Mod&quot;]]</code></pre><pre>import qualified Mod hiding (x,y)</pre><pre><code class="ml">renaming_scope [] [&quot;Mod&quot;] @@ meet [hide [&quot;x&quot;]; hide [&quot;y&quot;]]</code></pre></header></section><section><header><h3 id="racket"><a href="#racket" class="anchor"></a>Racket</h3><pre>(require (only-in ... id0 [old-id1 new-id1]))</pre><pre><code class="ml">seq_filter [...; join [only [&quot;id0&quot;]; renaming [&quot;old-id1&quot;] [&quot;new-id1&quot;]]]</code></pre><pre>(require (except-in ... id0 id1]))</pre><pre><code class="ml">seq_filter [...; except [&quot;id0&quot;]; except [&quot;id1&quot;]]</code></pre><pre>(require (prefix-in p: ...))</pre><pre><code class="ml">seq [...; renaming_prefix [] [&quot;p:&quot;]]</code></pre><pre>(require (rename-in ... [old-id0 new-id0] [old-id1 new-id1]))</pre><pre><code class="ml">seq [...; join [renaming [&quot;old-id0&quot;] [&quot;new-id0&quot;]; renaming [&quot;old-id1&quot;] [&quot;new-id1&quot;]]]</code></pre><pre>(require (combine-in require-spec0 require-spec1 ...))</pre><pre><code class="ml">join [require-spec0; require-spec1; ...]</code></pre><p>The <code>provide</code> mechanism can be simulated in a similar way. This library does not directly support the phase levels in Racket (yet).</p></header></section></section><section><header><h2 id="what-is-&quot;yuujinchou&quot;?"><a href="#what-is-&quot;yuujinchou&quot;?" class="anchor"></a>What is &quot;Yuujinchou&quot;?</h2><p>&quot;Yuujinchou&quot; is the transliteration of &quot;友人帳&quot; in Japanese, which literally means &quot;book of friends&quot;. It is a powerful notebook in the manga Natsume Yuujinchou (夏目友人帳) that collects many <em>real names (真名)</em> of youkais (妖怪) (supernatural and spiritual monsters). These real names can be used to summon and control youkais, but the protagonist decided to return the names to their original owners. The plot is about meeting all kinds of youkais.</p><p>This magical book will automatically turn to the page with the correct name when the protagonist pictures the youkai in his mind. This library is also about finding real names of youkais.</p><p>The transliteration is in the Wāpuro style to use only English alphabet letters; otherwise, its Hepburn romanization would be &quot;Yūjin-chō&quot;.</p></header></section></div></body></html>