<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Yuujinchou (yuujinchou.Yuujinchou)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">yuujinchou</a> &#x00BB; Yuujinchou</nav><h1>Module <code>Yuujinchou</code></h1><p><b>Yuujinchou</b> is an OCaml package of name patterns. It was motivated by the &quot;import&quot; or &quot;include&quot; statements present in almost all programming languages. Here are a few examples:</p><pre>open import M -- Agda</pre><pre>import foo # Python</pre><p>The ability to import content from other files helps organize code. However, it also poses a new challenge: how could programmers prevent imported content from shadowing existing content? For example, if we already have a function <code>test</code> in the current scope, maybe we do not wish to import another function also named <code>test</code>. To address this, many programming languages allow programmers to selectively hide or rename part of the imported content:</p><pre>open import M renaming (a to b) public
-- (Agda) renaming a to b, and then re-exporting the content</pre><p>Another way to address this is to place the imported content under some namespace. For example, in Python,</p><pre>import math # Python: the sqrt function is available as  `math.sqrt`.</pre><p>The goal of the Yuujinchou library is to provide a calculus of these modifications. If we view the collection of hierarchical names as a trie, then these name modifiers are trie transformers, and they should be composable. Currently, it supports renaming, scopes, sequencing, unions, and custom hooks for more advanced patterns.</p><h3 id="notes-on-namespaces"><a href="#notes-on-namespaces" class="anchor"></a>Notes on Namespaces</h3><p>This package intends to treat a namespace as the prefix of a group of names; there is no namespace <code>a</code>, but a group of unrelated names that happen to have the prefix <code>a</code>. This is different from many other designs which attempt to group a collection of bindings as a module. It is possible that such a design is unnecessarily limited unless one wishes to implement parametric signature polymorphism (without row polymorphism).</p><nav class="toc"><ul><li><a href="#modules-in-this-package">Modules in this Package</a></li><li><a href="#example-code">Example Code</a></li><li><a href="#examples-from-other-languages">Examples from Other Languages</a><ul><li><a href="#haskell">Haskell</a></li><li><a href="#racket">Racket</a></li></ul></li><li><a href="#what-is-&quot;yuujinchou&quot;?">What is &quot;Yuujinchou&quot;?</a></li></ul></nav></header><section><header><h2 id="modules-in-this-package"><a href="#modules-in-this-package" class="anchor"></a>Modules in this Package</h2><p>The code is split into three parts:</p></header><dl><dt class="spec module" id="module-Trie"><a href="#module-Trie" class="anchor"></a><code><span class="keyword">module</span> <a href="Trie/index.html">Trie</a> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="index.html#module-Trie">Trie</a></code></dt><dd><p>The <a href="Trie/index.html"><code>Trie</code></a> module implements a data structure that maps paths to values and supports efficient subtree operations.</p></dd></dl><dl><dt class="spec module" id="module-Pattern"><a href="#module-Pattern" class="anchor"></a><code><span class="keyword">module</span> <a href="Pattern/index.html">Pattern</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <a href="Pattern/index.html"><code>Pattern</code></a> module defines the patterns.</p></dd></dl><dl><dt class="spec module" id="module-Action"><a href="#module-Action" class="anchor"></a><code><span class="keyword">module</span> <a href="Action/index.html">Action</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <a href="Action/index.html"><code>Action</code></a> module implements the engine running the patterns.</p></dd></dl></section><section><header><h2 id="example-code"><a href="#example-code" class="anchor"></a>Example Code</h2><pre><code class="ml">open Yuujinchou

module Data =
struct
  type t = int
  let equal n1 n2 = n1 = n2
  let merge ~rev_path x y =
    if equal x y then x
    else failwith @@
      &quot;Inconsistent data assigned to the same path &quot; ^ String.concat &quot;.&quot; @@ List.rev rev_path
  let shadow ~rev_path:_ _x y = y
  let compare : t -&gt; t -&gt; int = compare
end

(** An environment is a mapping from paths to data. *)
type env = Data.t Trie.t

(** [remap pattern env] uses the [pattern] to massage
    the environment [env]. *)
let remap pattern env =
  let pp_path = function [] -&gt; &quot;(root)&quot; | path -&gt; String.concat &quot;.&quot; path in
  match Action.run ~union:Data.merge pattern env with
  | Ok env -&gt; env
  | Error (`BindingNotFound path) -&gt;
    failwith (&quot;Expected binding(s) not found within the subtree at &quot; ^ pp_path path ^ &quot;.&quot;)

(** [import env pattern imported] imports the environment
    [imported] massaged by [pattern] into [env]. *)
let import env pattern imported =
  Trie.union Data.shadow env @@ remap pattern imported

module DataSet = Set.Make (Data)

(** [select env pattern] returns the set of matched data. *)
let select env pattern =
  DataSet.of_seq @@ Trie.to_seq_values @@ remap pattern env</code></pre></header></section><section><header><h2 id="examples-from-other-languages"><a href="#examples-from-other-languages" class="anchor"></a>Examples from Other Languages</h2><p>This section shows how import mechanisms can be implemented using this package.</p></header><section><header><h3 id="haskell"><a href="#haskell" class="anchor"></a>Haskell</h3><ul><li><p>Haskell syntax:</p><pre>import Mod -- x is available an both x and Mod.x</pre><p>Corresponding Yuujinchou pattern:</p><pre><code class="ml">Pattern.(union [any; renaming_subtree [] [&quot;Mod&quot;]])</code></pre></li></ul><ul><li><p>Haskell syntax:</p><pre>import Mod (x,y)</pre><p>Corresponding Yuujinchou pattern:</p><pre><code class="ml">Pattern.(union [only [&quot;x&quot;]; only [&quot;y&quot;]])</code></pre></li></ul><ul><li><p>Haskell syntax:</p><pre>import qualified Mod</pre><p>Corresponding Yuujinchou pattern:</p><pre><code class="ml">Pattern.renaming_subtree [] [&quot;Mod&quot;]</code></pre></li></ul><ul><li><p>Haskell syntax:</p><pre>import qualified Mod hiding (x,y)</pre><p>Corresponding Yuujinchou pattern:</p><pre><code class="ml">Pattern.(seq [except [&quot;x&quot;]; except [&quot;y&quot;]; renaming_subtree [] [&quot;Mod&quot;]])</code></pre></li></ul></header></section><section><header><h3 id="racket"><a href="#racket" class="anchor"></a>Racket</h3><ul><li><p>Racket syntax:</p><pre>(require (only-in ... id0 [old-id1 new-id1]))</pre><p>Corresponding Yuujinchou pattern:</p><pre><code class="ml">Pattern.(seq [...; union [only [&quot;id0&quot;]; seq [only [&quot;old-id1&quot;]; renaming [&quot;old-id1&quot;] [&quot;new-id1&quot;]]]])</code></pre></li></ul><ul><li><p>Racket syntax:</p><pre>(require (except-in ... id0 id1]))</pre><p>Corresponding Yuujinchou pattern:</p><pre><code class="ml">Pattern.(seq [...; except [&quot;id0&quot;]; except [&quot;id1&quot;]])</code></pre></li></ul><ul><li><p>Racket syntax:</p><pre>(require (prefix-in p: ...))</pre><p>Corresponding Yuujinchou pattern:</p><pre><code class="ml">Pattern.(seq [...; renaming_subtree [] [&quot;p&quot;]])</code></pre></li></ul><ul><li><p>Racket syntax:</p><pre>(require (rename-in ... [old-id0 new-id0] [old-id1 new-id1]))</pre><p>Corresponding Yuujinchou pattern:</p><pre><code class="ml">Pattern.(seq [...; renaming [&quot;old-id0&quot;] [&quot;new-id0&quot;]; renaming [&quot;old-id1&quot;] [&quot;new-id1&quot;]])</code></pre></li></ul><ul><li><p>Racket syntax:</p><pre>(require (combine-in require-spec0 require-spec1 ...))</pre><p>Corresponding Yuujinchou pattern:</p><pre><code class="ml">Pattern.(union [require-spec0; require-spec1; ...])</code></pre></li></ul></header></section></section><section><header><h2 id="what-is-&quot;yuujinchou&quot;?"><a href="#what-is-&quot;yuujinchou&quot;?" class="anchor"></a>What is &quot;Yuujinchou&quot;?</h2><p>&quot;Yuujinchou&quot; is the transliteration of &quot;友人帳&quot; in Japanese, which literally means &quot;book of friends&quot;. It is a powerful notebook in the manga Natsume Yuujinchou (夏目友人帳) that collects many <em>real names (真名)</em> of youkais (妖怪) (supernatural and spiritual monsters). These real names can be used to summon and control youkais, but the protagonist decided to return the names to their original owners. The plot is about meeting all kinds of youkais.</p><p>This magical book will automatically turn to the page with the correct name when the protagonist pictures the youkai in his mind. This package is also about finding real names of youkais.</p><p>Notes on the transliteration: &quot;Yuujinchou&quot; is in the Wāpuro style so that it uses only the English alphabet; otherwise, its Hepburn romanization would be &quot;Yūjin-chō&quot;.</p></header></section></div></body></html>