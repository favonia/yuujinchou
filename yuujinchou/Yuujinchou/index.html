<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Yuujinchou (yuujinchou.Yuujinchou)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">yuujinchou</a> &#x00BB; Yuujinchou</nav><h1>Module <code>Yuujinchou</code></h1><p><b>Yuujinchou</b> is an OCaml package of name patterns. It was motivated by the &quot;import&quot; or &quot;include&quot; statements present in almost all programming languages. Here are a few examples:</p><pre>open import M -- Agda</pre><pre>import foo # Python</pre><p>The ability to import content from other files helps organize code. However, it also poses a new challenge: how could programmers prevent imported content from shadowing existing content? For example, if we already have a function <code>test</code> in the current scope, maybe we do not wish to import another function also named <code>test</code>. To address this, many programming languages allow programmers to selectively hide or rename part of the imported content:</p><pre>open import M renaming (a to b) public
-- renaming a to b, and then re-exporting the content</pre><pre>import foo as bar
# putting content of foo under the prefix bar</pre><p>We can view a collection of hierarchical names as a tree, and see these modifiers as tree transformers. I took this aspect seriously and designed a powerful (possibly overkilling) combinator calculus to express such tree transformers---the library you are checking now. It supports renaming, scopes, sequencing, unions, generic filtering.</p><nav class="toc"><ul><li><a href="#organization">Organization</a></li><li><a href="#how-to-use-it">How to Use It</a></li><li><a href="#namespace?">Namespace?</a></li><li><a href="#examples-from-other-languages">Examples from Other Languages</a><ul><li><a href="#haskell">Haskell</a></li><li><a href="#racket">Racket</a></li></ul></li><li><a href="#what-is-&quot;yuujinchou&quot;?">What is &quot;Yuujinchou&quot;?</a></li></ul></nav></header><section><header><h2 id="organization"><a href="#organization" class="anchor"></a>Organization</h2><p>The code is split into three parts:</p></header><dl><dt class="spec module" id="module-Trie"><a href="#module-Trie" class="anchor"></a><code><span class="keyword">module</span> <a href="Trie/index.html">Trie</a> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="index.html#module-Trie">Trie</a></code></dt><dd><p>The <a href="Trie/index.html"><code>Trie</code></a> module implements a data structure (tries) that supports efficient subtree operators on a collection of hierarchical names and their associated data.</p></dd></dl><dl><dt class="spec module" id="module-Pattern"><a href="#module-Pattern" class="anchor"></a><code><span class="keyword">module</span> <a href="Pattern/index.html">Pattern</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <a href="Pattern/index.html"><code>Pattern</code></a> module defines the patterns.</p></dd></dl><dl><dt class="spec module" id="module-Action"><a href="#module-Action" class="anchor"></a><code><span class="keyword">module</span> <a href="Action/index.html">Action</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <a href="Action/index.html"><code>Action</code></a> module implements the engine running the patterns.</p></dd></dl></section><section><header><h2 id="how-to-use-it"><a href="#how-to-use-it" class="anchor"></a>How to Use It</h2><pre><code class="ml">open Yuujinchou

module Data =
struct
  type t = int
  let equal n1 n2 = n1 = n2
  let merge x y =
    if equal x y then x
    else failwith &quot;Inconsistent data assigned to the same path.&quot;
  let shadow _x y = y
  let compare : t -&gt; t -&gt; int = compare
end

(** An environment is a mapping from paths to data. *)
type env = Data.t Trie.t

(** [remap pattern env] uses the [pattern] to massage
    the environment [env]. *)
let remap pattern env =
  let pp_path = function [] -&gt; &quot;(root)&quot; | path -&gt; String.concat &quot;.&quot; path in
  match Action.run Data.merge pattern env with
  | Ok env -&gt; env
  | Error (Action.BindingNotFound path) -&gt;
    failwith (&quot;Expected binding(s) not found within the subtree at &quot; ^ pp_path path ^ &quot;.&quot;)

(** [import env pattern imported] imports the environment
    [imported] massaged by [pattern] into [env]. *)
let import env pattern imported =
  Trie.union Data.shadow env @@ remap pattern imported

module DataSet = Set.Make (Data)

(** [select env pattern] returns the set of matched data. *)
let select env pattern =
  DataSet.of_seq @@ Trie.to_seq_values @@ remap pattern env</code></pre></header></section><section><header><h2 id="namespace?"><a href="#namespace?" class="anchor"></a>Namespace?</h2><p>This library intends to treat a namespace as the prefix of a group of names. That is, there is no namespace <code>a</code>, but only a group of unrelated names that happen to have the prefix <code>a</code>.</p><p>Note that namespaces (name prefixes of unrelated items) are different from modules (groups of items that are bound together). This library does not provide special support for modules (yet).</p></header></section><section><header><h2 id="examples-from-other-languages"><a href="#examples-from-other-languages" class="anchor"></a>Examples from Other Languages</h2></header><section><header><h3 id="haskell"><a href="#haskell" class="anchor"></a>Haskell</h3><pre>import Mod -- x is available an both x and Mod.x</pre><pre><code class="ml">union [any; renaming_subtree [] [&quot;Mod&quot;]]</code></pre><pre>import Mod (x,y)</pre><pre><code class="ml">union [only [&quot;x&quot;]; only [&quot;y&quot;]]</code></pre><pre>import qualified Mod</pre><pre><code class="ml">renaming_subtree [] [&quot;Mod&quot;]</code></pre><pre>import qualified Mod hiding (x,y)</pre><pre><code class="ml">seq [except [&quot;x&quot;]; except [&quot;y&quot;]; renaming_subtree [] [&quot;Mod&quot;]]</code></pre></header></section><section><header><h3 id="racket"><a href="#racket" class="anchor"></a>Racket</h3><pre>(require (only-in ... id0 [old-id1 new-id1]))</pre><pre><code class="ml">seq [...; union [only [&quot;id0&quot;]; seq [only [&quot;old-id1&quot;]; renaming [&quot;old-id1&quot;] [&quot;new-id1&quot;]]]]</code></pre><pre>(require (except-in ... id0 id1]))</pre><pre><code class="ml">seq [...; except [&quot;id0&quot;]; except [&quot;id1&quot;]]</code></pre><pre>(require (prefix-in p: ...))</pre><pre><code class="ml">seq [...; renaming_subtree [] [&quot;p&quot;]]</code></pre><pre>(require (rename-in ... [old-id0 new-id0] [old-id1 new-id1]))</pre><pre><code class="ml">seq [...; renaming [&quot;old-id0&quot;] [&quot;new-id0&quot;]; renaming [&quot;old-id1&quot;] [&quot;new-id1&quot;]]</code></pre><pre>(require (combine-in require-spec0 require-spec1 ...))</pre><pre><code class="ml">union [require-spec0; require-spec1; ...]</code></pre><p>The <code>provide</code> mechanism can be implemented in a similar way, and the phases can be handled via <a href="Pattern/index.html#val-filter_map"><code>Pattern.filter_map</code></a>.</p></header></section></section><section><header><h2 id="what-is-&quot;yuujinchou&quot;?"><a href="#what-is-&quot;yuujinchou&quot;?" class="anchor"></a>What is &quot;Yuujinchou&quot;?</h2><p>&quot;Yuujinchou&quot; is the transliteration of &quot;友人帳&quot; in Japanese, which literally means &quot;book of friends&quot;. It is a powerful notebook in the manga Natsume Yuujinchou (夏目友人帳) that collects many <em>real names (真名)</em> of youkais (妖怪) (supernatural and spiritual monsters). These real names can be used to summon and control youkais, but the protagonist decided to return the names to their original owners. The plot is about meeting all kinds of youkais.</p><p>This magical book will automatically turn to the page with the correct name when the protagonist pictures the youkai in his mind. This library is also about finding real names of youkais.</p><p>The transliteration is in the Wāpuro style to use only English alphabet letters; otherwise, its Hepburn romanization would be &quot;Yūjin-chō&quot;.</p></header></section></div></body></html>