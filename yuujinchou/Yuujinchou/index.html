<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Yuujinchou (yuujinchou.Yuujinchou)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">yuujinchou</a> &#x00BB; Yuujinchou</nav><h1>Module <code>Yuujinchou</code></h1><nav class="toc"><ul><li><a href="#introduction">Introduction</a></li><li><a href="#applications">Applications</a></li><li><a href="#organization">Organization</a></li><li><a href="#namespace-support">Namespace Support</a></li><li><a href="#examples">Examples</a><ul><li><a href="#haskell">Haskell</a></li></ul></li><li><a href="#what-is-&quot;yuujinchou&quot;?">What is &quot;Yuujinchou&quot;?</a></li></ul></nav></header><dl><dt class="spec module" id="module-Pattern"><a href="#module-Pattern" class="anchor"></a><code><span class="keyword">module</span> <a href="Pattern/index.html">Pattern</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <a href="Pattern/index.html"><code>Pattern</code></a> module defines the patterns.</p></dd></dl><dl><dt class="spec module" id="module-Action"><a href="#module-Action" class="anchor"></a><code><span class="keyword">module</span> <a href="Action/index.html">Action</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The <a href="Action/index.html"><code>Action</code></a> module implements the engine runnig the patterns.</p></dd></dl><section><header><h2 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h2><p><b>Yuujinchou</b> is an OCaml combinator library for manipulating names. It was motivated by the `import` or `include` statements present in almost all programming languages. Here are some examples of such statements:</p><pre>open import M -- Agda</pre><pre>import foo # Python</pre><p>The ability to import content from other files helps organize code. However, it also brings up new design issues: how could programmers prevent imported content from colliding or shadowing the existing content in the current scope? For example, maybe in the current scope, we have defined a function called <code>test</code>, and do not want to import another function also called <code>test</code>. To address this, many programming languages allow programmers to selectively hide or rename part of the imported content:</p><pre>open import M renaming (a to b) public
-- renaming a to b, and then re-exporting the content</pre><pre>import foo as bar
# putting content of foo under the prefix bar</pre><p>We can treat hiding or renaming as a partial function from names to names. I took this aspect seriously and designed this combinator library---a concise yet powerful (perhaps overkilling) language for manipulating names in programming languages.</p></header></section><section><header><h2 id="applications"><a href="#applications" class="anchor"></a>Applications</h2><p>This library was motivated by the import mechanism in most programming languages, but can be used in any situation involving selecting names. For example, during interactive theorem proving, perhaps you want to unfold some definitions but not others. This library gives you a powerful language to support fancy name selection.</p></header></section><section><header><h2 id="organization"><a href="#organization" class="anchor"></a>Organization</h2><p>The code is split into two parts: <a href="Pattern/index.html"><code>Pattern</code></a> and <a href="Action/index.html"><code>Action</code></a>.</p></header></section><section><header><h2 id="namespace-support"><a href="#namespace-support" class="anchor"></a>Namespace Support</h2><p>This library intends to treat a namespace as the prefix of a group of names. That is, there is no namespace <code>a</code>, but only a group of unrelated names that happen to have the prefix <code>a</code>.</p><p>Note that namespaces (name prefixes of unrelated declarations) are different from modules (groups of declarations that are bound together). This library does not provide special support for modules (yet).</p></header></section><section><header><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2></header><section><header><h3 id="haskell"><a href="#haskell" class="anchor"></a>Haskell</h3><pre>import Mod -- x is available an both x and Mod.x</pre><pre><code class="ml">join [any; renaming_prefix [] [&quot;Mod&quot;]]</code></pre><pre>import Mod (x,y)</pre><pre><code class="ml">join [id [&quot;x&quot;]; id [&quot;y&quot;]]</code></pre><pre>import qualified Mod</pre><pre><code class="ml">join [renaming_prefix [] [&quot;Mod&quot;]]</code></pre><pre>import qualified Mod hiding (x,y)</pre><pre><code class="ml">renaming_scope [] [&quot;Mod&quot;] @@ meet [hide [&quot;x&quot;]; hide [&quot;y&quot;]]</code></pre></header></section></section><section><header><h2 id="what-is-&quot;yuujinchou&quot;?"><a href="#what-is-&quot;yuujinchou&quot;?" class="anchor"></a>What is &quot;Yuujinchou&quot;?</h2><p>&quot;Yuujinchou&quot; is the transliteration of &quot;友人帳&quot; in Japanese, which literally means &quot;book of friends&quot;. The book is a powerful booklet that collects <em>real names (真名)</em> of youkais (妖怪) (supernatural and spiritual monsters) in the manga and anime Natsume Yuujinchou (夏目友人帳). These real names can be used to control youkais, but the protagonist decided to return the names to youkais. The plot is about meeting different youkais during the journey.</p><p>This library is also about using names to summon monsters.</p><p>The transliteration is in the Wāpuro style to work around the name restriction; otherwise, its Hepburn romanization would be &quot;Yūjin-chō&quot;.</p></header></section></div></body></html>