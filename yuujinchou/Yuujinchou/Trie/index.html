<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Trie (yuujinchou.Yuujinchou.Trie)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">yuujinchou</a> &#x00BB; <a href="../index.html">Yuujinchou</a> &#x00BB; Trie</nav><h1>Module <code>Yuujinchou.Trie</code></h1><p>The <a href="index.html"><code>Trie</code></a> module implements a data structure (tries) that supports efficient subtree operators on a collection of hierarchical names and their associated data.</p><nav class="toc"><ul><li><a href="#types">Types</a></li><li><a href="#basic-operations">Basic Operations</a></li><li><a href="#finding-values">Finding Values</a></li><li><a href="#mapping-and-filtering">Mapping and Filtering</a></li><li><a href="#updating">Updating</a></li><li><a href="#union">Union</a></li><li><a href="#separation">Separation</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#pretty-printer">Pretty Printer</a></li><li><a href="#physical-equality">Physical Equality</a></li></ul></nav></header><aside></aside><section><header><h2 id="types"><a href="#types" class="anchor"></a>Types</h2></header><dl><dt class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><code><span class="keyword">type</span> path</code><code> = <span>string list</span></code></dt><dd><p>The type of hierarchical names. The name <code>x.y.z</code> is represented by the OCaml list <code>[&quot;x&quot;; &quot;y&quot;; &quot;z&quot;]</code>.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>+'a t</span></code></dt><dd><p>The abstract type of a trie.</p></dd></dl></section><section><header><h2 id="basic-operations"><a href="#basic-operations" class="anchor"></a>Basic Operations</h2></header><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>The empty trie.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check whether the trie is empty.</p></dd></dl><dl><dt class="spec value" id="val-mk_root"><a href="#val-mk_root" class="anchor"></a><code><span class="keyword">val</span> mk_root : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Make a trie with only one binding: the root associated with the provided value. <code>mk_root None</code> will make an empty trie and <code>mk_root (Some v)</code> will make a trie with the value <code>v</code>. If thi input is always <code>Some v</code>, use <a href="index.html#val-root"><code>root</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-prefix"><a href="#val-prefix" class="anchor"></a><code><span class="keyword">val</span> prefix : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>prefix p t</code> makes a minimum trie with <code>t</code> rooted at <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <span>(<a href="index.html#type-path">path</a> * <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>strington (p, d)</code> makes a trie with the only binding: <code>p</code> and its associated value <code>d</code>.</p></dd></dl><dl><dt class="spec value" id="val-root"><a href="#val-root" class="anchor"></a><code><span class="keyword">val</span> root : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>root d</code> makes a trie with the only binding: the root and its associated value <code>d</code>. It is equivalent to <code>singleton [] d</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal eq t1 t2</code> checks whether two tries are equal. It the internal representations of tries are physically equal, <code>equal eq t1 t2</code> will return <code>true</code> without calling <code>eq</code>.</p></dd></dl></section><section><header><h2 id="finding-values"><a href="#finding-values" class="anchor"></a>Finding Values</h2></header><dl><dt class="spec value" id="val-find_subtree"><a href="#val-find_subtree" class="anchor"></a><code><span class="keyword">val</span> find_subtree : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>find_subtree p t</code> returns the subtree rooted at <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_singleton"><a href="#val-find_singleton" class="anchor"></a><code><span class="keyword">val</span> find_singleton : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>find_singleton p t</code> returns the value at <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_root"><a href="#val-find_root" class="anchor"></a><code><span class="keyword">val</span> find_root : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>find_root t</code> returns the value at the root. This is equivalent to <code>find_singleton [] t</code>.</p></dd></dl></section><section><header><h2 id="mapping-and-filtering"><a href="#mapping-and-filtering" class="anchor"></a>Mapping and Filtering</h2></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map f t</code> applies the function <code>f</code> to each value <code>v</code> in the trie.</p></dd></dl><dl><dt class="spec value" id="val-map_endo"><a href="#val-map_endo" class="anchor"></a><code><span class="keyword">val</span> map_endo : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map_endo f t</code> is similar to <code>map f t</code> except that the domain and the codomain of the function must be the same and the physical equality is preserved when <code>f</code> is an identity function.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filter f t</code> removes the values <code>v</code> where <code>f v</code> returns <code>false</code>. If <code>f v</code> returns <code>true</code> for every value in <code>t</code>, the <code>t</code> is returned unchanged.</p></dd></dl><dl><dt class="spec value" id="val-filter_map_endo"><a href="#val-filter_map_endo" class="anchor"></a><code><span class="keyword">val</span> filter_map_endo : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filter_map_endo f t</code> applies the function <code>f</code> to each value <code>v</code> in the trie. If <code>f v</code> returns <code>None</code>, then the binding will be removed from the trie. Otherwise, if <code>f v</code> returns <code>Some v'</code>, then the value will be replaced by <code>v'</code> in the returned trie.</p></dd></dl></section><section><header><h2 id="updating"><a href="#updating" class="anchor"></a>Updating</h2></header><dl><dt class="spec value" id="val-update_subtree"><a href="#val-update_subtree" class="anchor"></a><code><span class="keyword">val</span> update_subtree : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>update_subtree p f t</code> replaces the subtree <code>t'</code> rooted at <code>p</code> in <code>t</code> with <code>f t'</code>. It will try to preserve physical equality when <code>f</code> returns the trie unchanged.</p></dd></dl><dl><dt class="spec value" id="val-update_singleton"><a href="#val-update_singleton" class="anchor"></a><code><span class="keyword">val</span> update_singleton : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>update_singleton p f t</code> replaces the value <code>v</code> at <code>p</code> in <code>t</code> with the result of <code>f</code>. If there was no binding at <code>p</code>, <code>f None</code> is evaluated. Otherwise, <code>f (Some v)</code> is used. If the result is <code>None</code>, the old binding at <code>p</code> (if any) is removed. Otherwise, if the result is <code>Some v'</code>, the value at <code>p</code> is replaced by <code>v'</code>. It will try to preserve physical equality when <code>f</code> maintains the current status of binding, either returning <code>None</code> for <code>None</code> or <code>Some v</code> for <code>Some v</code>.</p></dd></dl><dl><dt class="spec value" id="val-update_root"><a href="#val-update_root" class="anchor"></a><code><span class="keyword">val</span> update_root : <span>(<span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>update_root f t</code> updates the value at root with <code>f</code>. It is equivalent to <code>update_singleton [] f t</code>.</p></dd></dl></section><section><header><h2 id="union"><a href="#union" class="anchor"></a>Union</h2></header><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>union merger t1 t2</code> merges two tries <code>t1</code> and <code>t2</code>. If both tries have a binding at the same path, it will call the function <code>merger</code> to reconcile the values from the two tries.</p></dd></dl><dl><dt class="spec value" id="val-union_subtree"><a href="#val-union_subtree" class="anchor"></a><code><span class="keyword">val</span> union_subtree : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<a href="index.html#type-path">path</a> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>union_subtree merger t1 (path, t2)</code> is equivalent to <code>union merger t1 (prefix t2)</code>, but potentially more efficient.</p></dd></dl><dl><dt class="spec value" id="val-union_singleton"><a href="#val-union_singleton" class="anchor"></a><code><span class="keyword">val</span> union_singleton : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<a href="index.html#type-path">path</a> * <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>union_singleton merger t binding</code> is equivalent to <code>union merger t1 (singleton binding)</code>, but potentially more efficient.</p></dd></dl></section><section><header><h2 id="separation"><a href="#separation" class="anchor"></a>Separation</h2></header><dl><dt class="spec value" id="val-detach_subtree"><a href="#val-detach_subtree" class="anchor"></a><code><span class="keyword">val</span> detach_subtree : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>detach p t</code> detaches the subtree at <code>p</code> from the main trie and returns both the subtree and the remaining trie. If <code>detach p t</code> returns <code>t1, t2</code>, then <code>union_subtree m t2 (p, t1)</code> should be equivalent to <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-detach_singleton"><a href="#val-detach_singleton" class="anchor"></a><code><span class="keyword">val</span> detach_singleton : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>detach p t</code> detaches the binding at <code>p</code> from the main trie and returns both the binding and the remaining trie. If <code>detach p t</code> returns <code>b, t'</code>, then <code>union_subtree m t' (p, mk_root b)</code> should be equivalent to <code>t</code>.</p></dd></dl></section><section><header><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2></header><dl><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-path">path</a> * <span class="type-var">'a</span>)</span> Stdlib.Seq.t</span></code></dt><dd><p><code>to_seq t</code> traverses through the trie <code>t</code> in the lexicographical order.</p></dd></dl><dl><dt class="spec value" id="val-to_seq_values"><a href="#val-to_seq_values" class="anchor"></a><code><span class="keyword">val</span> to_seq_values : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Stdlib.Seq.t</span></code></dt><dd><p><code>to_seq_values t</code> traverses through the trie <code>t</code> in the lexicographical order but only returns the associated values. This is faster than <code>Seq.map snd @@ to_seq t</code> because it does not need to reconstruct the paths.</p></dd></dl><dl><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-path">path</a> * <span class="type-var">'a</span>)</span> Stdlib.Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_seq m s</code> inserts bindings <code>(p, d)</code> into an empty trie, one by one, using <a href="index.html#val-union_subtree"><code>union_subtree</code></a>.</p></dd></dl></section><section><header><h2 id="pretty-printer"><a href="#pretty-printer" class="anchor"></a>Pretty Printer</h2></header><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp pp_v t</code> prints out the content of <code>t</code>, using the pretty printer <code>pp_v</code> on values.</p></dd></dl></section><section><header><h2 id="physical-equality"><a href="#physical-equality" class="anchor"></a>Physical Equality</h2></header><dl><dt class="spec value" id="val-physically_equal"><a href="#val-physically_equal" class="anchor"></a><code><span class="keyword">val</span> physically_equal : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>This is an internal API for testing whether the library is preserving physical equality as much as possible. Do not use this function in other situtations. If <code>physically_equal t1 t2</code> returns <code>true</code> then <code>equal eq t1 t2</code> must return <code>true</code>.</p></dd></dl></section></div></body></html>