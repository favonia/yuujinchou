<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Trie (yuujinchou.Yuujinchou.Trie)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">yuujinchou</a> &#x00BB; <a href="../index.html">Yuujinchou</a> &#x00BB; Trie</nav><h1>Module <code>Yuujinchou.Trie</code></h1><p>The <a href="index.html"><code>Trie</code></a> module implements a data structure that maps paths to values and supports efficient subtree operations.</p><nav class="toc"><ul><li><a href="#types">Types</a></li><li><a href="#basic-operations">Basic Operations</a></li><li><a href="#finding-values">Finding Values</a></li><li><a href="#mapping-and-filtering">Mapping and Filtering</a></li><li><a href="#updating">Updating</a></li><li><a href="#union">Union</a></li><li><a href="#separation">Separation</a></li><li><a href="#iterators">Iterators</a></li></ul></nav></header><aside></aside><section><header><h2 id="types"><a href="#types" class="anchor"></a>Types</h2></header><dl><dt class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><code><span class="keyword">type</span> path</code><code> = <span>string list</span></code></dt><dd><p>The type of hierarchical names. The name <code>x.y.z</code> is represented by the OCaml list <code>[&quot;x&quot;; &quot;y&quot;; &quot;z&quot;]</code>.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>+'a t</span></code></dt><dd><p>The abstract type of a trie.</p></dd></dl></section><section><header><h2 id="basic-operations"><a href="#basic-operations" class="anchor"></a>Basic Operations</h2></header><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>The empty trie.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check whether the trie is empty.</p></dd></dl><dl><dt class="spec value" id="val-root"><a href="#val-root" class="anchor"></a><code><span class="keyword">val</span> root : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>root d</code> makes a trie with the only binding: the root and its associated value <code>d</code>. It is equivalent to <a href="index.html#val-root_opt"><code>root_opt</code></a><code>(Some d)</code>.</p></dd></dl><dl><dt class="spec value" id="val-root_opt"><a href="#val-root_opt" class="anchor"></a><code><span class="keyword">val</span> root_opt : <span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>root_opt d</code> is equivalent to <code>match d with None -&gt;</code><a href="index.html#val-empty"><code>empty</code></a><code>| Some d -&gt;</code><a href="index.html#val-root"><code>root</code></a><code>d</code>. In other words, <code>root_opt None</code> will make an empty trie and <code>root_opt (Some v)</code> will make a trie with only one binding: the root associated with the value <code>v</code>. If the input is always <code>Some v</code>, use <a href="index.html#val-root"><code>root</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-prefix"><a href="#val-prefix" class="anchor"></a><code><span class="keyword">val</span> prefix : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>prefix p t</code> makes a minimum trie with <code>t</code> rooted at <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <span>(<a href="index.html#type-path">path</a> * <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>singleton (p, d)</code> makes a trie with the only binding: <code>p</code> and its associated value <code>d</code>. It is equivalent to <a href="index.html#val-prefix"><code>prefix</code></a><code>p @@</code><a href="index.html#val-root"><code>root</code></a><code>d</code></p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal eq t1 t2</code> checks whether two tries are equal. If the internal representations of tries are physically equal, <code>equal eq t1 t2</code> will immediately return <code>true</code> without calling <code>eq</code>.</p></dd></dl></section><section><header><h2 id="finding-values"><a href="#finding-values" class="anchor"></a>Finding Values</h2></header><dl><dt class="spec value" id="val-find_subtree"><a href="#val-find_subtree" class="anchor"></a><code><span class="keyword">val</span> find_subtree : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>find_subtree p t</code> returns the subtree rooted at <code>p</code>.</p><dl><dt>returns</dt><dd><p>The subtrie with all the bindings under <code>p</code>, including the binding at <code>p</code> itself (which will be the root). If there are no such bindings with the prefix <code>p</code>, an empty trie is returned.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-find_singleton"><a href="#val-find_singleton" class="anchor"></a><code><span class="keyword">val</span> find_singleton : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>find_singleton p t</code> returns the value at <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_root"><a href="#val-find_root" class="anchor"></a><code><span class="keyword">val</span> find_root : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>find_root t</code> returns the value at the root. This is equivalent to <a href="index.html#val-find_singleton"><code>find_singleton</code></a><code>[] t</code>.</p></dd></dl></section><section><header><h2 id="mapping-and-filtering"><a href="#mapping-and-filtering" class="anchor"></a>Mapping and Filtering</h2></header><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span>(<span>rev_path:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri ~rev_prefix f t</code> applies the function <code>f</code> to each value <code>v</code> in the trie.</p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path sent to <code>f</code>, but in reverse. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span>(<span>rev_path:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>mapi ~rev_prefix f t</code> applies the function <code>f</code> to each value <code>v</code> in the trie.</p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path sent to <code>f</code>, but in reverse. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-mapi_endo"><a href="#val-mapi_endo" class="anchor"></a><code><span class="keyword">val</span> mapi_endo : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span>(<span>rev_path:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>mapi_endo ~rev_prefix f t</code> is similar to <a href="index.html#val-mapi"><code>mapi</code></a><code>f t</code> except that the domain and the codomain of the function must be the same. The additional benefit of <code>mapi_endo</code> over <code>mapi</code> is that, if <code>f v</code> returns <code>v</code> for every value <code>v</code> in <code>t</code>, then <code>t</code> is returned unchanged. (That is, the new trie will be physically equal to the old one.) See <code>filter_map_endo</code>.</p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path sent to <code>f</code>, but in reverse. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-filteri"><a href="#val-filteri" class="anchor"></a><code><span class="keyword">val</span> filteri : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span>(<span>rev_path:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filteri ~rev_prefix f t</code> removes all values <code>v</code> at path <code>p</code> such that <code>f ~rev_prefix:p v</code> returns <code>false</code>. If <code>f v</code> returns <code>true</code> for every value <code>v</code> in <code>t</code>, then <code>t</code> is returned unchanged. (That is, the new trie will be physically equal to the old one.)</p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path sent to <code>f</code>. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-filter_mapi"><a href="#val-filter_mapi" class="anchor"></a><code><span class="keyword">val</span> filter_mapi : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span>(<span>rev_path:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filter_mapi ~rev_prefix f t</code> applies the function <code>f</code> to each value <code>v</code> at <code>p</code> in the trie. If <code>f ~rev_prefix:p v</code> returns <code>None</code>, then the binding will be removed from the trie. Otherwise, if <code>f v</code> returns <code>Some v'</code>, then the value will be replaced by <code>v'</code>.</p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path sent to <code>f</code>, but in reverse. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-filter_mapi_endo"><a href="#val-filter_mapi_endo" class="anchor"></a><code><span class="keyword">val</span> filter_mapi_endo : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span>(<span>rev_path:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filter_mapi_endo ~rev_prefix f t</code> is similar to <a href="index.html#val-filter_mapi"><code>filter_mapi</code></a><code>~rev_prefix f t</code> except that <code>f</code> must be of type <code>rev_path:path -&gt; 'a -&gt; 'a option</code>; that is, its domain and codomain agree up to the <code>option</code> type. The additional benefit of <code>filter_mapi_endo</code> over <code>filter_mapi</code> is that if <code>f ~rev_prefix:p v</code> returns <code>Some v</code> for every value <code>v</code> at <code>p</code> in <code>t</code>, then <code>t</code> is returned unchanged. (That is, the new trie will be physically equal to the old one.) See <code>map_endo</code></p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path sent to <code>f</code>. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl></section><section><header><h2 id="updating"><a href="#updating" class="anchor"></a>Updating</h2></header><dl><dt class="spec value" id="val-update_subtree"><a href="#val-update_subtree" class="anchor"></a><code><span class="keyword">val</span> update_subtree : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>update_subtree p f t</code> replaces the subtree <code>t'</code> rooted at <code>p</code> in <code>t</code> with <code>f t'</code>. It will try to preserve physical equality when <code>f</code> returns the trie unchanged.</p></dd></dl><dl><dt class="spec value" id="val-update_singleton"><a href="#val-update_singleton" class="anchor"></a><code><span class="keyword">val</span> update_singleton : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>update_singleton p f t</code> replaces the value <code>v</code> at <code>p</code> in <code>t</code> with the result of <code>f</code>. If there was no binding at <code>p</code>, <code>f None</code> is evaluated. Otherwise, <code>f (Some v)</code> is used. If the result is <code>None</code>, the old binding at <code>p</code> (if any) is removed. Otherwise, if the result is <code>Some v'</code>, the value at <code>p</code> is replaced by <code>v'</code>. It will try to preserve physical equality when <code>f</code> maintains the current status of binding, either returning <code>None</code> for <code>None</code> or <code>Some v</code> for <code>Some v</code>.</p></dd></dl><dl><dt class="spec value" id="val-update_root"><a href="#val-update_root" class="anchor"></a><code><span class="keyword">val</span> update_root : <span>(<span><span class="type-var">'a</span> option</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>update_root f t</code> updates the value at root with <code>f</code>. It is equivalent to <a href="index.html#val-update_singleton"><code>update_singleton</code></a><code>[] f t</code>.</p></dd></dl></section><section><header><h2 id="union"><a href="#union" class="anchor"></a>Union</h2></header><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span>(<span>rev_path:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>union ~rev_prefix merger t1 t2</code> merges two tries <code>t1</code> and <code>t2</code>. If both tries have a binding at the same path <code>p</code>, it will call <code>merger ~rev_path:p x y</code> to reconcile the values <code>x</code> from <code>t1</code> and <code>y</code> from <code>t2</code> that are both bound at the (reversed) path <code>rev_path</code>. The path <code>rev_path</code> is reversed for efficient traversal.</p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path sent to <code>merger</code>. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-union_subtree"><a href="#val-union_subtree" class="anchor"></a><code><span class="keyword">val</span> union_subtree : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span>(<span>rev_path:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<a href="index.html#type-path">path</a> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>union_subtree ~rev_prefix merger t1 (path, t2)</code> is equivalent to <a href="index.html#val-union"><code>union</code></a><code>~rev_prefix merger t1 (prefix path t2)</code>, but potentially more efficient.</p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path sent to <code>merger</code>. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-union_singleton"><a href="#val-union_singleton" class="anchor"></a><code><span class="keyword">val</span> union_singleton : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span>(<span>rev_path:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<a href="index.html#type-path">path</a> * <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>union_singleton merger t binding</code> is equivalent to <a href="index.html#val-union"><code>union</code></a><code>merger t1 (singleton binding)</code>, but potentially more efficient.</p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path sent to <code>merger</code>. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl></section><section><header><h2 id="separation"><a href="#separation" class="anchor"></a>Separation</h2></header><dl><dt class="spec value" id="val-detach_subtree"><a href="#val-detach_subtree" class="anchor"></a><code><span class="keyword">val</span> detach_subtree : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>detach_subtree p t</code> detaches the subtree at <code>p</code> from the main trie and returns both the subtree and the remaining trie. If <code>detach p t</code> returns <code>t1, t2</code>, then <a href="index.html#val-union_subtree"><code>union_subtree</code></a><code>m t2 (p, t1)</code> should be equivalent to <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-detach_singleton"><a href="#val-detach_singleton" class="anchor"></a><code><span class="keyword">val</span> detach_singleton : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>detach_singleton p t</code> detaches the binding at <code>p</code> from the main trie and returns both the binding and the remaining trie. If <code>detach p t</code> returns <code>b, t'</code>, then <a href="index.html#val-union_subtree"><code>union_subtree</code></a><code>m t' (p,</code><a href="index.html#val-root_opt"><code>root_opt</code></a><code>b)</code> should be equivalent to <code>t</code>.</p></dd></dl></section><section><header><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2></header><dl><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-path">path</a> * <span class="type-var">'a</span>)</span> Stdlib.Seq.t</span></code></dt><dd><p><code>to_seq ~rev_prefix t</code> traverses through the trie <code>t</code> in the lexicographical order.</p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path in the output, but in reverse. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_seq_with_reversed_paths"><a href="#val-to_seq_with_reversed_paths" class="anchor"></a><code><span class="keyword">val</span> to_seq_with_reversed_paths : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-path">path</a> * <span class="type-var">'a</span>)</span> Stdlib.Seq.t</span></code></dt><dd><p><code>to_seq_with_reversed_paths</code> is like <a href="index.html#val-to_seq"><code>to_seq</code></a> but with paths reversed. This is potentially more efficient than <a href="index.html#val-to_seq"><code>to_seq</code></a>.</p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path in the output, but in reverse. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_seq_values"><a href="#val-to_seq_values" class="anchor"></a><code><span class="keyword">val</span> to_seq_values : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Stdlib.Seq.t</span></code></dt><dd><p><code>to_seq_values t</code> traverses through the trie <code>t</code> in the lexicographical order but only returns the associated values. This is potentially more efficient than <a href="index.html#val-to_seq"><code>to_seq</code></a> because path reversal is skipped.</p></dd></dl><dl><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : <span>?&#8288;rev_prefix:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span>(<span>rev_path:<a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-path">path</a> * <span class="type-var">'a</span>)</span> Stdlib.Seq.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_seq ~rev_prefix merger s</code> inserts bindings <code>(p, d)</code> into an empty trie, one by one, using <a href="index.html#val-union_subtree"><code>union_subtree</code></a>.</p><dl><dt>parameter rev_prefix</dt><dd><p>The prefix prepended to any path sent to <code>merger</code>, but in reverse. The default is the empty unit path (<code>[]</code>).</p></dd></dl></dd></dl></section></div></body></html>