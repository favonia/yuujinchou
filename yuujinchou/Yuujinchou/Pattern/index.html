<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pattern (yuujinchou.Yuujinchou.Pattern)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">yuujinchou</a> &#x00BB; <a href="../index.html">Yuujinchou</a> &#x00BB; Pattern</nav><h1>Module <code>Yuujinchou.Pattern</code></h1><p>The <a href="index.html"><code>Pattern</code></a> module defines the patterns.</p><nav class="toc"><ul><li><a href="#pattern-type">Pattern Type</a><ul><li><a href="#hierarchical-names">Hierarchical Names</a></li></ul></li><li><a href="#pattern-builders">Pattern Builders</a><ul><li><a href="#basics">Basics</a></li><li><a href="#negation">Negation</a></li><li><a href="#renaming">Renaming</a></li><li><a href="#attributes">Attributes</a></li><li><a href="#sequencing">Sequencing</a></li><li><a href="#logical-connectives">Logical Connectives</a></li><li><a href="#unsafe-builders">Unsafe Builders</a></li></ul></li><li><a href="#pretty-printers">Pretty printers</a></li><li><a href="#core">Core Language</a><ul><li><a href="#results">Results</a></li><li><a href="#modes">Modes</a></li><li><a href="#combinators">Combinators</a><ul><li><a href="#wildcard-(patwildcard)">Wildcard (<code>PatWildcard</code>)</a></li><li><a href="#scope-renaming-(patscope)">Scope Renaming (<code>PatScope</code>)</a></li><li><a href="#sequencing-(patseq)">Sequencing (<code>PatSeq</code>)</a></li><li><a href="#mode-inversion-(patinv)">Mode Inversion (<code>PatInv</code>)</a></li><li><a href="#join-and-meet-(patjoin)">Join and Meet (<code>PatJoin</code>)</a></li><li><a href="#attribute-assignment-(patattr)">Attribute Assignment (<code>PatAttr</code>)</a></li></ul></li><li><a href="#invariants">Invariants</a></li></ul></li></ul></nav></header><section><header><h2 id="pattern-type"><a href="#pattern-type" class="anchor"></a>Pattern Type</h2></header><dl><dt class="spec type" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span class="keyword">type</span> <span>'a pattern</span></code></dt><dd><p>The type of patterns, parametrized by the attribute type. See <a href="index.html#attributes"><span>Attributes</span></a> for more information about attributes.</p></dd></dl><aside><p>The pattern type is abstract---you should build a pattern using the following builders. The detail of the core language is at the end of this page. Use <a href="../Action/index.html#val-run"><code>Action.run</code></a> to execute a pattern.</p></aside><section><header><h3 id="hierarchical-names"><a href="#hierarchical-names" class="anchor"></a>Hierarchical Names</h3></header><dl><dt class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><code><span class="keyword">type</span> path</code><code> = <span>string list</span></code></dt><dd><p>The type of names.</p></dd></dl><aside><p>We assume names are hierarchical and can be encoded as lists of strings. For example, the name <code>a.b.c</code> is represented as the following OCaml list:</p><pre><code class="ml">[&quot;a&quot;; &quot;b&quot;; &quot;c&quot;]</code></pre></aside></section></section><section><header><h2 id="pattern-builders"><a href="#pattern-builders" class="anchor"></a>Pattern Builders</h2></header><section><header><h3 id="basics"><a href="#basics" class="anchor"></a>Basics</h3></header><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern that matches any name.</p></dd></dl><dl><dt class="spec value" id="val-none"><a href="#val-none" class="anchor"></a><code><span class="keyword">val</span> none : <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern that matches no names.</p></dd></dl><dl><dt class="spec value" id="val-id"><a href="#val-id" class="anchor"></a><code><span class="keyword">val</span> id : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern <code>id x</code> that matches the name <code>x</code> and nothing else.</p></dd></dl><dl><dt class="spec value" id="val-wildcard"><a href="#val-wildcard" class="anchor"></a><code><span class="keyword">val</span> wildcard : <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The wildcard pattern that matches everything except for the empty name (the empty list <code>[]</code>).</p></dd></dl><dl><dt class="spec value" id="val-root"><a href="#val-root" class="anchor"></a><code><span class="keyword">val</span> root : <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern that only matches the empty name (the empty list <code>[]</code>).</p></dd></dl><dl><dt class="spec value" id="val-scope"><a href="#val-scope" class="anchor"></a><code><span class="keyword">val</span> scope : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>Scoping a pattern with a prefix. For example, <code>scope p (id x)</code> is equivalent to <code>id (p @ x)</code></p></dd></dl><dl><dt class="spec value" id="val-prefix"><a href="#val-prefix" class="anchor"></a><code><span class="keyword">val</span> prefix : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern that matches any name with the given prefix. The pattern <code>prefix p</code> is equivalent to <code>scope p any</code>.</p></dd></dl></section><section><header><h3 id="negation"><a href="#negation" class="anchor"></a>Negation</h3></header><dl><dt class="spec value" id="val-skip"><a href="#val-skip" class="anchor"></a><code><span class="keyword">val</span> skip : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern that skips the specified name.</p></dd></dl><dl><dt class="spec value" id="val-skip_prefix"><a href="#val-skip_prefix" class="anchor"></a><code><span class="keyword">val</span> skip_prefix : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern that skips any name with the specified prefix.</p></dd></dl></section><section><header><h3 id="renaming"><a href="#renaming" class="anchor"></a>Renaming</h3></header><dl><dt class="spec value" id="val-renaming"><a href="#val-renaming" class="anchor"></a><code><span class="keyword">val</span> renaming : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern that matches only the specified name and replaces it.</p></dd></dl><dl><dt class="spec value" id="val-renaming_prefix"><a href="#val-renaming_prefix" class="anchor"></a><code><span class="keyword">val</span> renaming_prefix : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern that matches any name with the given prefix and replaces the prefix.</p></dd></dl><dl><dt class="spec value" id="val-renaming_scope"><a href="#val-renaming_scope" class="anchor"></a><code><span class="keyword">val</span> renaming_scope : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>Scoping a pattern and rename the prefix.</p></dd></dl></section><section><header><h3 id="attributes"><a href="#attributes" class="anchor"></a>Attributes</h3></header><aside><p>Attributes are custom tags attached to matched names. For example, you could attach <code>`Public</code> or <code>`Private</code> to names when implementing the import statement. You need to supply a default value and a lattice structure for your attribute type <code>t</code> when running the pattern using <a href="../Action/index.html#val-run"><code>Action.run</code></a>:</p><ol><li><p>A default value of type <code>t</code>.</p><p>The default attribute attached to the new names until the engine encounters the pattern created via <a href="index.html#attributes"><span>Attributes</span></a> that explicitly sets a new default attribute.</p></li><li><p>A join operator of type <code>t -&gt; t -&gt; t</code>.</p><p>An operator to resolve the conflicting attributes by taking their &quot;union&quot;. The exact meaning of &quot;union&quot; depends on the lattice structure. This is for reconciling conflicting attributes when running patterns generated by <a href="index.html#val-seq"><code>seq</code></a>, <a href="index.html#val-seq_filter"><code>seq_filter</code></a> or <a href="index.html#val-join"><code>join</code></a>.</p></li><li><p>A meet operator of type <code>t -&gt; t -&gt; t</code>.</p><p>An operator to resolve the conflicting attributes by taking their &quot;intersection&quot;. The exact meaning of &quot;intersection&quot; depends on the lattice structure. This is for reconciling conflicting attributes when running patterns generated by <a href="index.html#val-meet"><code>meet</code></a>.</p></li></ol><p>For example, when implementing the traditional import statement, the attribute type can be</p><pre><code class="ml">type attr = [ `Public | `Private ]</code></pre><p>and then the meet and join operators can be implemented as follows:</p><pre><code class="ml">let join_attr a1 a2 =
  match a1, a2 with
  | `Public, _ | _, `Public -&gt; `Public
  | `Private, `Private -&gt; `Private

let meet_attr a1 a2 =
  match a1, a2 with
  | `Private, _ | _, `Private -&gt; `Private
  | `Public, `Public -&gt; `Public</code></pre><p>In other words, <code>`Pubilc</code> is treated as the top element and <code>`Private</code> is the bottom element. The rationale is that if a name is simultanously imported as a public name (to be re-exported) and a private name (not to be re-exported), then in most programming languages it <em>will</em> be re-exported. This suggests that the join operator should outputs <code>`Public</code> whenever one of the inputs is <code>`Public</code>. It then makes sense to make the meet operator the dual of the join operator.</p><p>The following pattern changes the default attribute before running the subpattern:</p></aside><dl><dt class="spec value" id="val-attr"><a href="#val-attr" class="anchor"></a><code><span class="keyword">val</span> attr : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern <code>attr a p</code> will assigns the default attribute to <code>a</code> and then runs the pattern <code>p</code>.</p></dd></dl></section><section><header><h3 id="sequencing"><a href="#sequencing" class="anchor"></a>Sequencing</h3></header><dl><dt class="spec value" id="val-seq"><a href="#val-seq" class="anchor"></a><code><span class="keyword">val</span> seq : <span><span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern <code>seq [p0; p1; p2; ...; pn]</code> runs the patterns <code>p0</code>, <code>p1</code>, <code>p2</code>, ..., <code>pn</code> in order.</p><p>If <code>pi</code> triggers the renaming, then the new names are used in the subsequent patterns. A name is considered matched if it is matched by any pattern during the process. Inconsistent attributes on the same name are resolved by the provided <code>join</code> operator. See <a href="index.html#attributes"><span>Attributes</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-seq_filter"><a href="#val-seq_filter" class="anchor"></a><code><span class="keyword">val</span> seq_filter : <span><span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p>The pattern <code>seq_filter [p0; p1; p2; ...; pn]</code> is almost the same as <code>seq [p0; p1; p2; ...; pn]</code>, except that a name is considered matched only when it is matched (and potentially renamed) by all the patterns in the list. Inconsistent attributes on the same name are resolved by the provided <code>join</code> operator. See <a href="index.html#attributes"><span>Attributes</span></a>.</p></dd></dl></section><section><header><h3 id="logical-connectives"><a href="#logical-connectives" class="anchor"></a>Logical Connectives</h3></header><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span><span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>join [p0; p1; p2; ...; pn]</code> is the join of the patterns <code>p0</code>, <code>p1</code>, <code>p2</code>, ..., <code>pn</code>. A name is considered matched when it is matched by any subpattern. Inconsistent attributes assigned by the subpatterns are resolved by the provided <code>join</code> operator on attributes. See <a href="index.html#attributes"><span>Attributes</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-meet"><a href="#val-meet" class="anchor"></a><code><span class="keyword">val</span> meet : <span><span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>meet [p0; p1; p2; ...; pn]</code> is the meet of a non-empty list of patterns <code>p0</code>, <code>p1</code>, <code>p2</code>, ..., <code>pn</code>. If the list is empty, <a href="index.html#val-meet"><code>meet</code></a> will raise <code>Invalid_argument</code>. A name is considered matched only when it is matched by all the subpatterns. If a name is matched in all subpatterns, but the intersection of the new names is empty, then the name is still considered matched, with an empty set of new names. Inconsistent attributes assigned by the subpatterns are resolved by the provided <code>meet</code> operator on attributes. See <a href="index.html#attributes"><span>Attributes</span></a>.</p></dd></dl></section><section><header><h3 id="unsafe-builders"><a href="#unsafe-builders" class="anchor"></a>Unsafe Builders</h3></header><dl><dt class="spec value" id="val-unsafe_meet"><a href="#val-unsafe_meet" class="anchor"></a><code><span class="keyword">val</span> unsafe_meet : <span><span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>unsafe_meet l</code> is the same as <code>meet l</code> except that it does not check whether the list is empty. This might be useful to build subpatterns that would temporarily violate the invariant. See <a href="index.html#invariants"><span>Invariants</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_inv"><a href="#val-unsafe_inv" class="anchor"></a><code><span class="keyword">val</span> unsafe_inv : <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>unsafe_inv p</code> negates the meaning of pattern <code>p</code>. This might be useful to build more efficient patterns by temporarily violating the invariants. Please read <a href="index.html#core"><span>Core Language</span></a> for more the detail. See also <a href="index.html#invariants"><span>Invariants</span></a>.</p></dd></dl></section></section><section><header><h2 id="pretty-printers"><a href="#pretty-printers" class="anchor"></a>Pretty printers</h2></header><dl><dt class="spec value" id="val-pp_path"><a href="#val-pp_path" class="anchor"></a><code><span class="keyword">val</span> pp_path : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty printer for <a href="index.html#type-path"><code>path</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-pp_pattern"><a href="#val-pp_pattern" class="anchor"></a><code><span class="keyword">val</span> pp_pattern : <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty printer for <a href="index.html#type-pattern"><code>pattern</code></a>.</p></dd></dl></section><section><header><h2 id="core"><a href="#core" class="anchor"></a>Core Language</h2><p>Here is the current implementation of <a href="index.html#type-pattern"><code>pattern</code></a>:</p><pre><code class="ml">type 'a pattern =
  | PatWildcard
  | PatScope of path * path option * 'a pattern
  | PatSeq of 'a pattern list
  | PatInv of 'a pattern
  | PatJoin of 'a pattern list
  | PatAttr of 'a * 'a pattern</code></pre><p>We will explain each combinator, one by one. However, it is essential to know the possible results of pattern matching and <em>modes</em> first.</p></header><section><header><h3 id="results"><a href="#results" class="anchor"></a>Results</h3><p>The result of pattern matching is one of the following:</p><ol><li><code>Ok `NoMatch</code>: the pattern runs without errors but does not match the name.</li><li><code>Ok `Matched [(name_1, attr_1); (name_2, attr_2); ...]</code>: the pattern matches the name and outputs its new names tagged with attributes. (See <a href="index.html#attributes"><span>Attributes</span></a>) It is possible that the set of new names is empty despite the old name being matched because we support the intersection operator <a href="index.html#val-meet"><code>meet</code></a>.</li><li><code>Error err</code>: the pattern is ill-formed, violating the invariants described in <a href="index.html#invariants"><span>Invariants</span></a>.</li></ol><p>See <a href="../Action/index.html#type-result_"><code>Action.result_</code></a>, <a href="../Action/index.html#type-error"><code>Action.error</code></a> and <a href="../Action/index.html#val-run"><code>Action.run</code></a>.</p></header></section><section><header><h3 id="modes"><a href="#modes" class="anchor"></a>Modes</h3><p>There are two modes of the pattern matching engine: the <em>normal</em> mode and the <em>inverse</em> mode. The motivation to have the inverse mode is to implement the patterns that hide names from being imported. Think about the pattern <code>id [&quot;a&quot;; &quot;b&quot;]</code>, which would normally select the name <code>a.b</code> from the imported content. Its dual meaning---selecting everything <em>other than</em> the name <code>a.b</code>---is exactly the hiding operator we are looking for. The inverse mode has been extended to the entire core language and significantly reduce the number of combinators. It is recommended to study how the core language works under the normal mode first.</p></header></section><section><header><h3 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h3></header><section><header><h4 id="wildcard-(patwildcard)"><a href="#wildcard-(patwildcard)" class="anchor"></a>Wildcard (<code>PatWildcard</code>)</h4><p>The wildcard pattern <code>PatWildcard</code> under the normal mode matches every name except for the root (the empty list <code>[]</code>). The same pattern under the inverse mode matches nothing but the root (the empty list <code>[]</code>). In either case, if a name <code>p</code> is matched, then the output is <code>Ok (Match [p, a])</code> where <code>a</code> is the inherited default attribute.</p></header></section><section><header><h4 id="scope-renaming-(patscope)"><a href="#scope-renaming-(patscope)" class="anchor"></a>Scope Renaming (<code>PatScope</code>)</h4><p>The pattern <code>PatScope (p, None, pat)</code> under the normal mode identifies any name with the prefix <code>p</code> and then runs <code>pat</code> against the residual part of the name. For example, <code>PatScope ([&quot;a&quot;; &quot;b&quot;], None, PatWildcard)</code> will first identify the name <code>a.b.c</code> (represented by <code>[&quot;a&quot;; &quot;b&quot;; &quot;c&quot;]</code>) because it has the prefix <code>[&quot;a&quot;; &quot;b&quot;]</code>, and then the pattern <code>PatWildcard</code> will match the remaining part <code>c</code>. The same pattern under the inverse mode will match any name whose prefix is <em>not</em> <code>p</code>, and any name that has the prefix <code>p</code> but fails to match <code>pat</code> after removing the prefix <code>p</code>.</p><p>The pattern <code>PatScope (p, Some r, pattern)</code> is the same as <code>PatScope (p, None, pattern)</code> expect that the prefix <code>p</code>, if matched, will be replaced by <code>r</code>. The same pattern under the inverse mode will result into an error because the replacement <code>r</code> would not be used.</p></header></section><section><header><h4 id="sequencing-(patseq)"><a href="#sequencing-(patseq)" class="anchor"></a>Sequencing (<code>PatSeq</code>)</h4><p>The pattern <code>PatSeq [pat_1; pat_2; ...; pat_n]</code> under the normal mode runs the patterns <code>pat_1</code>, <code>pat_2</code>, ..., <code>pat_n</code> in order. New names generated by previous patterns (possibly through the scope renaming operator <code>PatScope</code>) are used in later patterns. A name is matched if it is matched by any pattern in the sequence during the process. It is possible that a name is renamed into multiple names during the process, and these renamings are merged by taking the union of all possible renamings, where conflicting attributes are resolved by the join operation in the attribute lattice. As a special case, <code>PatSeq []</code> under the normal mode matches nothing.</p><p>The same pattern <code>PatSeq [pat_1; pat_2; ...; pat_n]</code> under the inverse mode also runs the patterns <code>pat_1</code>, <code>pat_2</code>, ..., <code>pat_n</code> in order, but with a twist: a name is matched only if it is matched by all patterns in the sequence. Overlapping renamings and conflicting attributes are resolved by the unions and joins. As a special case, <code>PatSeq []</code> under the inverse mode matches any name, including the root (represented by <code>[]</code>), which is different from the wildcard pattern (<code>PatWildcard</code>).</p></header></section><section><header><h4 id="mode-inversion-(patinv)"><a href="#mode-inversion-(patinv)" class="anchor"></a>Mode Inversion (<code>PatInv</code>)</h4><p>The pattern <code>PatInv pat</code> flips the current mode of the engine (from the normal mode to the inverse mode or vice versa) and proceed with the pattern <code>pat</code>.</p></header></section><section><header><h4 id="join-and-meet-(patjoin)"><a href="#join-and-meet-(patjoin)" class="anchor"></a>Join and Meet (<code>PatJoin</code>)</h4><p><code>PatJoin [pat_1; pat_2; ...; pat_n]</code> under the normal mode runs the subpatterns independently and takes the join of the renaming relations. The same pattern under the inverse mode takes the meet of the renaming relations instead. However, the pattern <code>PatJoin []</code> under the inverse mode will result into an error because there is not an unit of the meet of patterns.</p><p>There is one trick case about the meet operation: Assume we have two different names <code>x</code> and <code>y</code>. The meet of <code>`Matched [x, a]</code> and <code>`Matched [y, a]</code> is <code>`Matched []</code>, not <code>`NoMatch</code>. It means the name is matched but there are no new names for it.</p></header></section><section><header><h4 id="attribute-assignment-(patattr)"><a href="#attribute-assignment-(patattr)" class="anchor"></a>Attribute Assignment (<code>PatAttr</code>)</h4><p>The pattern <code>PatAttr (attr, pat)</code> sets the default attribute to <code>attr</code> before running the pattern <code>pat</code>. It does not change the mode of the engine.</p></header></section></section><section><header><h3 id="invariants"><a href="#invariants" class="anchor"></a>Invariants</h3><p>Patterns involving renaming (e.g., <code>PatScope (p, Some r, pattern)</code>) and the empty join pattern <code>PatJoin []</code> should not be run under the inverse mode.</p></header></section></section></div></body></html>