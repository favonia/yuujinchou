<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pattern (yuujinchou.Yuujinchou.Pattern)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">yuujinchou</a> &#x00BB; <a href="../index.html">Yuujinchou</a> &#x00BB; Pattern</nav><h1>Module <code>Yuujinchou.Pattern</code></h1><p>The <a href="index.html"><code>Pattern</code></a> module defines the patterns.</p><nav class="toc"><ul><li><a href="#pattern-type">Pattern Type</a><ul><li><a href="#hierarchical-names">Hierarchical Names</a></li></ul></li><li><a href="#pattern-builders">Pattern Builders</a><ul><li><a href="#basics">Basics</a></li><li><a href="#negation">Negation</a></li><li><a href="#renaming">Renaming</a></li><li><a href="#attributes">Attributes</a></li><li><a href="#sequencing">Sequencing</a></li><li><a href="#logical-connectives">Logical Connectives</a></li><li><a href="#unsafe-builders">Unsafe Builders</a></li></ul></li><li><a href="#pretty-printers">Pretty Printers</a></li><li><a href="#core">Core Language</a><ul><li><a href="#outcomes">Outcomes</a></li><li><a href="#modes">Modes</a></li><li><a href="#combinators">Combinators</a><ul><li><a href="#wildcard-(patwildcard)">Wildcard (<code>PatWildcard</code>)</a></li><li><a href="#scope-renaming-(patscope)">Scope Renaming (<code>PatScope</code>)</a></li><li><a href="#sequencing-(patseq)">Sequencing (<code>PatSeq</code>)</a></li><li><a href="#mode-inversion-(patinv)">Mode Inversion (<code>PatInv</code>)</a></li><li><a href="#join-and-meet-(patjoin)">Join and Meet (<code>PatJoin</code>)</a></li><li><a href="#attribute-assignment-(patattr)">Attribute Assignment (<code>PatAttr</code>)</a></li></ul></li><li><a href="#invariants">Invariants</a></li></ul></li></ul></nav></header><section><header><h2 id="pattern-type"><a href="#pattern-type" class="anchor"></a>Pattern Type</h2></header><dl><dt class="spec type" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span class="keyword">type</span> <span>'a pattern</span></code></dt><dd><p>The type of patterns, parametrized by the attribute type. See <a href="index.html#attributes"><span>Attributes</span></a> for more information about attributes.</p></dd></dl><aside><p>The pattern type is abstract---you should build a pattern using the following builders. The detail of the core language is at the end of this page. Use <a href="../Action/index.html#val-compile"><code>Action.compile</code></a> and <a href="../Action/index.html#val-run"><code>Action.run</code></a> to execute a pattern.</p></aside><section><header><h3 id="hierarchical-names"><a href="#hierarchical-names" class="anchor"></a>Hierarchical Names</h3></header><dl><dt class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><code><span class="keyword">type</span> path</code><code> = <span>string list</span></code></dt><dd><p>The type of names.</p></dd></dl><aside><p>We assume names are hierarchical and can be encoded as lists of strings. For example, the name <code>a.b.c</code> is represented as the following OCaml list:</p><pre><code class="ml">[&quot;a&quot;; &quot;b&quot;; &quot;c&quot;]</code></pre></aside></section></section><section><header><h2 id="pattern-builders"><a href="#pattern-builders" class="anchor"></a>Pattern Builders</h2></header><section><header><h3 id="basics"><a href="#basics" class="anchor"></a>Basics</h3></header><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>any</code> matches any name.</p></dd></dl><dl><dt class="spec value" id="val-only"><a href="#val-only" class="anchor"></a><code><span class="keyword">val</span> only : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>only x</code> matches the name <code>x</code> and nothing else.</p></dd></dl><dl><dt class="spec value" id="val-root"><a href="#val-root" class="anchor"></a><code><span class="keyword">val</span> root : <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>root</code> matches only the empty name (the empty list <code>[]</code>). It is equivalent to <code>only []</code>.</p></dd></dl><dl><dt class="spec value" id="val-wildcard"><a href="#val-wildcard" class="anchor"></a><code><span class="keyword">val</span> wildcard : <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>wildcard</code> matches everything <em>except</em> the empty name (the empty list <code>[]</code>). It is the opposite of <code>root</code>.</p></dd></dl><dl><dt class="spec value" id="val-prefix"><a href="#val-prefix" class="anchor"></a><code><span class="keyword">val</span> prefix : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>prefix p</code> matches any name with the given prefix <code>p</code> and is equivalent to <code>scope p any</code>.</p></dd></dl><dl><dt class="spec value" id="val-scope"><a href="#val-scope" class="anchor"></a><code><span class="keyword">val</span> scope : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>scope p pat</code> picks out names with the prefix <code>p</code> and runs the pattern <code>pat</code> on the remaining part of them. For example, <code>scope [&quot;a&quot;; &quot;b&quot;] pat</code> on the name <code>a.b.c.d</code> will factor out the prefix <code>a.b</code> and continue running the pattern <code>pat</code> on the remaining part <code>c.d</code>.</p><p><a href="index.html#val-scope"><code>scope</code></a> is more general than <a href="index.html#val-only"><code>only</code></a> and <a href="index.html#val-prefix"><code>prefix</code></a>: <code>only x</code> is equivalent to <code>scope x root</code> and <code>prefix p</code> is equivalent to <code>scope p any</code>.</p></dd></dl></section><section><header><h3 id="negation"><a href="#negation" class="anchor"></a>Negation</h3></header><dl><dt class="spec value" id="val-none"><a href="#val-none" class="anchor"></a><code><span class="keyword">val</span> none : <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>none</code> matches no names. It is the opposite of <a href="index.html#val-any"><code>any</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-except"><a href="#val-except" class="anchor"></a><code><span class="keyword">val</span> except : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>except x</code> matches any name <em>except</em> <code>x</code>. It is the opposite of <a href="index.html#val-only"><code>only</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-except_prefix"><a href="#val-except_prefix" class="anchor"></a><code><span class="keyword">val</span> except_prefix : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>except_prefix p</code> matches any name that does not have the prefix <code>p</code>. It is the opposite of <a href="index.html#val-prefix"><code>prefix</code></a>.</p></dd></dl></section><section><header><h3 id="renaming"><a href="#renaming" class="anchor"></a>Renaming</h3></header><dl><dt class="spec value" id="val-renaming"><a href="#val-renaming" class="anchor"></a><code><span class="keyword">val</span> renaming : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>renaming x x'</code> matches the name <code>x</code> and replaces it with <code>x'</code>. See <a href="index.html#val-only"><code>only</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-renaming_prefix"><a href="#val-renaming_prefix" class="anchor"></a><code><span class="keyword">val</span> renaming_prefix : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>renaming_prefix p p'</code> matches any name with the prefix <code>p</code> and replaces the prefix with <code>p'</code>. See <a href="index.html#val-prefix"><code>prefix</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-renaming_scope"><a href="#val-renaming_scope" class="anchor"></a><code><span class="keyword">val</span> renaming_scope : <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>renaming_scope p p' pat</code> is the same as <code>scope p pat</code> except that the prefix will be replaced by <code>p'</code>. See <a href="index.html#val-scope"><code>scope</code></a>.</p><p><a href="index.html#val-renaming_scope"><code>renaming_scope</code></a> is more general than <a href="index.html#val-renaming"><code>renaming</code></a> and <a href="index.html#val-renaming_prefix"><code>renaming_prefix</code></a>: <code>renaming x x'</code> is equivalent to <code>renaming_scope x x' root</code> and <code>renaming_prefix p p'</code> is equivalent to <code>renaming_scope p p' any</code>.</p></dd></dl></section><section><header><h3 id="attributes"><a href="#attributes" class="anchor"></a>Attributes</h3></header><aside><p>Attributes are custom tags attached to matched names. For example, you could attach <code>`Public</code> or <code>`Private</code> to names when implementing the import statement. You need to supply a lattice structure for your attribute type <code>t</code> when compiling a pattern using <a href="../Action/index.html#val-compile"><code>Action.compile</code></a>, and then specify a default attribute when running the compiled pattern using <a href="../Action/index.html#val-run"><code>Action.run</code></a>. Here are the components you need to execute a pattern:</p><ol><li><p>A join operator of type <code>t -&gt; t -&gt; t</code>.</p><p>An operator to resolve the conflicting attributes by taking their &quot;union&quot;. It is used when running patterns built by <a href="index.html#val-seq"><code>seq</code></a>, <a href="index.html#val-seq_filter"><code>seq_filter</code></a> or <a href="index.html#val-join"><code>join</code></a>. The exact meaning of &quot;union&quot; depends on the lattice structure.</p></li><li><p>A meet operator of type <code>t -&gt; t -&gt; t</code>.</p><p>An operator to resolve the conflicting attributes by taking their &quot;intersection&quot;. It is used when running patterns built by <a href="index.html#val-meet"><code>meet</code></a>. The exact meaning of &quot;intersection&quot; depends on the lattice structure.</p></li><li><p>A default value of type <code>t</code>.</p><p>The default attribute attached to the new names until the engine encounters the pattern created via <a href="index.html#val-attr"><code>attr</code></a> that explicitly sets a new default attribute.</p></li></ol><p>For example, when implementing the traditional import statement, the attribute type can be</p><pre><code class="ml">type attr = [ `Public | `Private ]</code></pre><p>and then the meet and join operators can be implemented as follows:</p><pre><code class="ml">let join_attr a1 a2 =
  match a1, a2 with
  | `Public, _ | _, `Public -&gt; `Public
  | `Private, `Private -&gt; `Private

let meet_attr a1 a2 =
  match a1, a2 with
  | `Private, _ | _, `Private -&gt; `Private
  | `Public, `Public -&gt; `Public</code></pre><p>In other words, <code>`Public</code> is treated as the top element and <code>`Private</code> is the bottom element. The rationale is that if a name is simultanously imported as a public name (to be re-exported) and a private name (not to be re-exported), then in most programming languages it <em>will</em> be re-exported. This suggests that the join operator should outputs <code>`Public</code> whenever one of the inputs is <code>`Public</code>. It then makes sense to make the meet operator the dual of the join operator.</p><p>To pass the lattice structure to the compiler <a href="../Action/index.html#val-compile"><code>Action.compile</code></a>, use</p><pre><code class="ml">let compiled_pat = Action.compile ~join:join_attr ~meet:meet pat</code></pre><p>To pass the default value to the <a href="../Action/index.html#val-run"><code>Action.run</code></a>, use</p><pre><code class="ml">Action.run compiled_pat ~default:`Private path</code></pre><p>Please read <a href="index.html#outcomes"><span>Outcomes</span></a> on how attributes are attached to the results.</p><p>The following pattern changes the default attribute before running the subpattern:</p></aside><dl><dt class="spec value" id="val-attr"><a href="#val-attr" class="anchor"></a><code><span class="keyword">val</span> attr : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>attr a p</code> assigns the default attribute to <code>a</code> and then runs the pattern <code>p</code>.</p></dd></dl></section><section><header><h3 id="sequencing"><a href="#sequencing" class="anchor"></a>Sequencing</h3></header><dl><dt class="spec value" id="val-seq"><a href="#val-seq" class="anchor"></a><code><span class="keyword">val</span> seq : <span><span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>seq [p0; p1; p2; ...; pn]</code> runs the patterns <code>p0</code>, <code>p1</code>, <code>p2</code>, ..., <code>pn</code> in order.</p><p>If a pattern triggers renaming, then the new names are used in the subsequent patterns. A name is considered matched if it is matched by any pattern during the process. Inconsistent attributes are resolved by the provided <code>join</code> operator. See <a href="index.html#attributes"><span>Attributes</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-seq_filter"><a href="#val-seq_filter" class="anchor"></a><code><span class="keyword">val</span> seq_filter : <span><span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>seq_filter [p0; p1; p2; ...; pn]</code> is almost the same as <code>seq [p0; p1; p2; ...; pn]</code>, except that a name is considered matched only when it is matched (and potentially renamed) by all the patterns in the list. Inconsistent attributes are resolved by the provided <code>join</code> operator. See <a href="index.html#attributes"><span>Attributes</span></a>.</p></dd></dl></section><section><header><h3 id="logical-connectives"><a href="#logical-connectives" class="anchor"></a>Logical Connectives</h3></header><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span><span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>join [p0; p1; p2; ...; pn]</code> calculates the &quot;union&quot; of the patterns <code>p0</code>, <code>p1</code>, <code>p2</code>, ..., <code>pn</code>. A name is considered matched when it is matched by any subpattern. Inconsistent attributes are resolved by the provided <code>join</code> operator on attributes. See <a href="index.html#attributes"><span>Attributes</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-meet"><a href="#val-meet" class="anchor"></a><code><span class="keyword">val</span> meet : <span><span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>meet [p0; p1; p2; ...; pn]</code> calculates the &quot;intersection&quot; of the patterns <code>p0</code>, <code>p1</code>, <code>p2</code>, ..., <code>pn</code>. There must be at least one subpattern; if the input list is empty, <a href="index.html#val-meet"><code>meet</code></a> will raise <code>Invalid_argument</code>. A name is considered matched only when it is matched by all the subpatterns. If a name is matched by all subpatterns, but the intersection of the new names is empty, then the name is still considered matched (with an empty set of new names). Inconsistent attributes are resolved by the provided <code>meet</code> operator on attributes. See <a href="index.html#attributes"><span>Attributes</span></a>.</p></dd></dl></section><section><header><h3 id="unsafe-builders"><a href="#unsafe-builders" class="anchor"></a>Unsafe Builders</h3></header><dl><dt class="spec value" id="val-unsafe_meet"><a href="#val-unsafe_meet" class="anchor"></a><code><span class="keyword">val</span> unsafe_meet : <span><span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>unsafe_meet l</code> is the same as <code>meet l</code> except that it does not check whether the list is empty. This might be useful for writing a parser for user-defined patterns. See also <a href="index.html#invariants"><span>Invariants</span></a>.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_inv"><a href="#val-unsafe_inv" class="anchor"></a><code><span class="keyword">val</span> unsafe_inv : <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span></code></dt><dd><p><code>unsafe_inv p</code> negates the meaning of pattern <code>p</code>, which might be useful for writing a parser or building more efficient patterns by temporarily violating the invariants. Please consult <a href="index.html#core"><span>Core Language</span></a> for more information on &quot;negation&quot;. See also <a href="index.html#invariants"><span>Invariants</span></a>.</p></dd></dl></section></section><section><header><h2 id="pretty-printers"><a href="#pretty-printers" class="anchor"></a>Pretty Printers</h2></header><dl><dt class="spec value" id="val-pp_path"><a href="#val-pp_path" class="anchor"></a><code><span class="keyword">val</span> pp_path : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-path">path</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty printer for <a href="index.html#type-path"><code>path</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-pp_pattern"><a href="#val-pp_pattern" class="anchor"></a><code><span class="keyword">val</span> pp_pattern : <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pattern">pattern</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty printer for <a href="index.html#type-pattern"><code>pattern</code></a>.</p></dd></dl></section><section><header><h2 id="core"><a href="#core" class="anchor"></a>Core Language</h2><p>Here is the current implementation of <a href="index.html#type-pattern"><code>pattern</code></a>:</p><pre><code class="ml">type 'a pattern =
  | PatWildcard
  | PatScope of path * path option * 'a pattern
  | PatSeq of 'a pattern list
  | PatInv of 'a pattern
  | PatJoin of 'a pattern list
  | PatAttr of 'a * 'a pattern</code></pre><p>We will explain each combinator, one by one. However, it is essential to know the outcomes of pattern matching and <em>modes</em> first.</p></header><section><header><h3 id="outcomes"><a href="#outcomes" class="anchor"></a>Outcomes</h3><p>The result of pattern matching is one of the following:</p><ol><li><code>`NoMatch</code>: the pattern does not match the name.</li><li><code>`Matched [(name_1, attr_1); (name_2, attr_2); ...]</code>: the pattern matches the name and outputs its new names tagged with attributes. If no renaming happens, then the name list is just a singleton list with the original name. For example, the pattern <code>Pattern.any</code> alone keeps the original name and tag it with the default attribute, so running it on a name <code>a.b</code> with the default attribute <code>def</code> will lead to the output <code>`Match [[&quot;a&quot;; &quot;b&quot;], def]</code>. The union operator <a href="index.html#val-join"><code>join</code></a> is the major source of multiple new names. It is possible that the set of new names is empty despite the old name being matched because we also support the intersection operator <a href="index.html#val-meet"><code>meet</code></a>.</li></ol><p>See also <a href="../Action/index.html#type-matching_result"><code>Action.matching_result</code></a> and <a href="../Action/index.html#val-run"><code>Action.run</code></a>.</p></header></section><section><header><h3 id="modes"><a href="#modes" class="anchor"></a>Modes</h3><p>There are two modes of the pattern matching engine: the <em>normal</em> mode and the <em>inverse</em> mode. The motivation to have the inverse mode is to implement the patterns that hide names from being imported. Think about the pattern <code>only [&quot;a&quot;; &quot;b&quot;]</code>, which would normally select the name <code>a.b</code> from the imported content. Its dual meaning---selecting everything <em>other than</em> the name <code>a.b</code>---is exactly the hiding operator we are looking for. The inverse mode has been extended to the entire core language and significantly reduced the number of combinators. It is recommended to study how the core language works under the normal mode first.</p></header></section><section><header><h3 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h3></header><section><header><h4 id="wildcard-(patwildcard)"><a href="#wildcard-(patwildcard)" class="anchor"></a>Wildcard (<code>PatWildcard</code>)</h4><p>The wildcard pattern <code>PatWildcard</code> under the normal mode matches every name except for the root (the empty list <code>[]</code>). The same pattern under the inverse mode matches nothing but the root (the empty list <code>[]</code>). In either case, if a name <code>p</code> is matched, then the output is <code>`Matched [p, a]</code> where <code>a</code> is the inherited default attribute.</p></header></section><section><header><h4 id="scope-renaming-(patscope)"><a href="#scope-renaming-(patscope)" class="anchor"></a>Scope Renaming (<code>PatScope</code>)</h4><p>The pattern <code>PatScope (p, None, pat)</code> under the normal mode identifies any name with the prefix <code>p</code> and then runs <code>pat</code> against the residual part of the name. For example, <code>PatScope ([&quot;a&quot;; &quot;b&quot;], None, PatWildcard)</code> will first identify the name <code>a.b.c</code> (represented by <code>[&quot;a&quot;; &quot;b&quot;; &quot;c&quot;]</code>) because it has the prefix <code>[&quot;a&quot;; &quot;b&quot;]</code>, and then the pattern <code>PatWildcard</code> will match the remaining part <code>c</code>. The same pattern under the inverse mode will match any name whose prefix is <em>not</em> <code>p</code>, and any name that has the prefix <code>p</code> but fails to match <code>pat</code> after removing the prefix <code>p</code>.</p><p>The pattern <code>PatScope (p, Some r, pattern)</code> is the same as <code>PatScope (p, None, pattern)</code> expect that the prefix <code>p</code>, if matched, will be replaced by <code>r</code>. The same pattern under the inverse mode will result into an error because the replacement <code>r</code> would not be used.</p></header></section><section><header><h4 id="sequencing-(patseq)"><a href="#sequencing-(patseq)" class="anchor"></a>Sequencing (<code>PatSeq</code>)</h4><p>The pattern <code>PatSeq [pat_1; pat_2; ...; pat_n]</code> under the normal mode runs the patterns <code>pat_1</code>, <code>pat_2</code>, ..., <code>pat_n</code> in order. New names generated by previous patterns (possibly through the scope renaming operator <code>PatScope</code>) are used in later patterns. A name is matched if it is matched by any pattern in the sequence during the process. It is possible that a name is renamed into multiple names during the process, and these renamings are merged by taking the union of all possible renamings, where conflicting attributes are resolved by the join operation in the attribute lattice. As a special case, <code>PatSeq []</code> under the normal mode matches nothing.</p><p>The same pattern <code>PatSeq [pat_1; pat_2; ...; pat_n]</code> under the inverse mode also runs the patterns <code>pat_1</code>, <code>pat_2</code>, ..., <code>pat_n</code> in order, but with a twist: a name is matched only if it is matched by all patterns in the sequence. Overlapping renamings and conflicting attributes are resolved by the unions and joins. As a special case, <code>PatSeq []</code> under the inverse mode matches any name, including the root (represented by <code>[]</code>), which is different from the wildcard pattern (<code>PatWildcard</code>).</p></header></section><section><header><h4 id="mode-inversion-(patinv)"><a href="#mode-inversion-(patinv)" class="anchor"></a>Mode Inversion (<code>PatInv</code>)</h4><p>The pattern <code>PatInv pat</code> flips the current mode of the engine (from the normal mode to the inverse mode or vice versa) and proceed with the pattern <code>pat</code>.</p></header></section><section><header><h4 id="join-and-meet-(patjoin)"><a href="#join-and-meet-(patjoin)" class="anchor"></a>Join and Meet (<code>PatJoin</code>)</h4><p><code>PatJoin [pat_1; pat_2; ...; pat_n]</code> under the normal mode runs the subpatterns independently and takes the join of the renaming relations. The same pattern under the inverse mode takes the meet of the renaming relations instead. However, the pattern <code>PatJoin []</code> under the inverse mode will result into an error because there is not an unit of the meet of patterns.</p><p>There is one trick case about the meet operation: Assume we have two different names <code>x</code> and <code>y</code>. The meet of <code>`Matched [x, a]</code> and <code>`Matched [y, a]</code> is <code>`Matched []</code>, not <code>`NoMatch</code>. It means the name is matched but there are no new names for it.</p></header></section><section><header><h4 id="attribute-assignment-(patattr)"><a href="#attribute-assignment-(patattr)" class="anchor"></a>Attribute Assignment (<code>PatAttr</code>)</h4><p>The pattern <code>PatAttr (attr, pat)</code> sets the default attribute to <code>attr</code> before running the pattern <code>pat</code>. It does not change the mode of the engine.</p></header></section></section><section><header><h3 id="invariants"><a href="#invariants" class="anchor"></a>Invariants</h3><p>Patterns involving renaming (e.g., <code>PatScope (p, Some r, pattern)</code>) and the empty join pattern <code>PatJoin []</code> should not be run under the inverse mode. This invariant is checked when using <a href="../Action/index.html#val-compile"><code>Action.compile</code></a> or <a href="../Action/index.html#val-compile_"><code>Action.compile_</code></a> to compile a pattern. It is impossible to violate the invariant unless <a href="index.html#val-unsafe_meet"><code>unsafe_meet</code></a> or <a href="index.html#val-unsafe_inv"><code>unsafe_inv</code></a> is used.</p></header></section></section></div></body></html>